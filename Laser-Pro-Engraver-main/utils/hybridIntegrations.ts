/**
 * Hybrid Integrations - Phase 3 Feature
 * 3D printing and CNC workflow integration
 */

export interface HybridWorkflow {
  id: string;
  name: string;
  steps: WorkflowStep[];
  status: 'pending' | 'in_progress' | 'completed' | 'failed';
}

export interface WorkflowStep {
  type: '3d_print' | 'cnc_mill' | 'laser_engrave' | 'laser_cut';
  order: number;
  settings: ThreeDPrintSettings | CNCSettings | LaserSettings;
  completed: boolean;
}

export interface LaserSettings {
  power: number;
  speed: number;
  passes: number;
  mode?: 'engrave' | 'cut';
}

export interface ThreeDPrintSettings {
  fileFormat: 'stl' | 'obj' | 'gcode';
  layerHeight: number;
  infill: number;
  material: string;
}

export interface CNCSettings {
  operation: 'mill' | 'drill' | 'engrave';
  toolDiameter: number;
  feedRate: number;
  depth: number;
}

/**
 * Create a hybrid workflow combining multiple processes
 */
export function createHybridWorkflow(name: string, steps: WorkflowStep[]): HybridWorkflow {
  return {
    id: `workflow-${Date.now()}`,
    name,
    steps: steps.sort((a, b) => a.order - b.order),
    status: 'pending',
  };
}

/**
 * Export laser job for 3D printer integration (engrave-then-print workflow)
 */
export function exportFor3DPrint(
  laserPaths: Array<{ x: number; y: number }[]>,
  printSettings: ThreeDPrintSettings
): { gcode: string; success: boolean } {
  let gcode = '; Laser engraving paths for 3D print integration\n';
  gcode += '; Generated by LaserTrace Pro - Hybrid Workflow\n\n';
  
  // Add laser paths as G-code comments or separate layer
  gcode += '; LASER ENGRAVING LAYER\n';
  laserPaths.forEach((path, index) => {
    gcode += `; Path ${index + 1}\n`;
    path.forEach((point, i) => {
      if (i === 0) {
        gcode += `G0 X${point.x.toFixed(3)} Y${point.y.toFixed(3)} ; Move to start\n`;
      } else {
        gcode += `G1 X${point.x.toFixed(3)} Y${point.y.toFixed(3)} ; Engrave\n`;
      }
    });
  });
  
  return {
    gcode,
    success: true,
  };
}

/**
 * Export laser job for CNC integration
 */
export function exportForCNC(
  laserPaths: Array<{ x: number; y: number }[]>,
  cncSettings: CNCSettings
): { gcode: string; success: boolean } {
  let gcode = '; CNC + Laser hybrid workflow\n';
  gcode += `; Tool: ${cncSettings.toolDiameter}mm ${cncSettings.operation}\n`;
  gcode += `; Feed rate: ${cncSettings.feedRate}mm/min\n\n`;
  
  // Convert laser paths to CNC-compatible G-code
  gcode += 'G21 ; Set units to millimeters\n';
  gcode += 'G90 ; Absolute positioning\n';
  gcode += `G0 Z${cncSettings.depth} ; Set working depth\n\n`;
  
  laserPaths.forEach((path, index) => {
    gcode += `; Path ${index + 1}\n`;
    path.forEach((point, i) => {
      if (i === 0) {
        gcode += `G0 X${point.x.toFixed(3)} Y${point.y.toFixed(3)} ; Rapid move\n`;
        gcode += `G1 Z-${cncSettings.depth} F${cncSettings.feedRate} ; Plunge\n`;
      } else {
        gcode += `G1 X${point.x.toFixed(3)} Y${point.y.toFixed(3)} F${cncSettings.feedRate}\n`;
      }
    });
    gcode += `G0 Z${cncSettings.depth} ; Retract\n`;
  });
  
  gcode += '\nG0 Z10 ; Final retract\n';
  gcode += 'M30 ; Program end\n';
  
  return {
    gcode,
    success: true,
  };
}

/**
 * Chain multiple processes in sequence
 */
export async function executeWorkflowChain(
  workflow: HybridWorkflow,
  onStepComplete?: (step: WorkflowStep) => void
): Promise<{ success: boolean; error?: string }> {
  try {
    workflow.status = 'in_progress';
    
    for (const step of workflow.steps) {
      // Simulate step execution
      await new Promise(resolve => setTimeout(resolve, 100));
      
      step.completed = true;
      
      if (onStepComplete) {
        onStepComplete(step);
      }
    }
    
    workflow.status = 'completed';
    return { success: true };
  } catch (error) {
    workflow.status = 'failed';
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error',
    };
  }
}

/**
 * Validate workflow compatibility
 */
export function validateWorkflow(workflow: HybridWorkflow): {
  valid: boolean;
  warnings: string[];
  errors: string[];
} {
  const warnings: string[] = [];
  const errors: string[] = [];
  
  if (workflow.steps.length === 0) {
    errors.push('Workflow must have at least one step');
  }
  
  // Check step order
  const orders = workflow.steps.map(s => s.order);
  const uniqueOrders = new Set(orders);
  if (uniqueOrders.size !== orders.length) {
    errors.push('Duplicate step orders detected');
  }
  
  // Check for logical sequences
  const hasLaser = workflow.steps.some(s => s.type.includes('laser'));
  const hasCNC = workflow.steps.some(s => s.type === 'cnc_mill');
  const has3D = workflow.steps.some(s => s.type === '3d_print');
  
  if (hasLaser && hasCNC) {
    warnings.push('Combining laser and CNC operations - ensure proper workpiece setup');
  }
  
  if (has3D && (hasLaser || hasCNC)) {
    warnings.push('3D print combined with subtractive process - verify step order');
  }
  
  return {
    valid: errors.length === 0,
    warnings,
    errors,
  };
}
